# CVE-2019-11043
PHP-FPM Remote Code Execution

Screencast: [https://youtu.be/d6benC5FVZM](https://youtu.be/d6benC5FVZM)

## Overview
This zero-day exploit in common PHP-FPM configurations was discovered during the _Realworld CTF_ competition in 2019. A regular expression is used to parse the requested URI, but newline characters `%0a` are not matched. This triggers a bug in FastCGI which computes the query string length incorrectly and writes a null byte to a location _before_ the start of the intended buffer. By careful selection of the query string length, an attacker can use this bug to overwrite internal PHP variables on the server and execute arbitrary shell code.

The original Go implementation of this exploit can be found in [here](https://github.com/neex/phuip-fpizdam). I have used this, [a write up](https://blog.orange.tw/2019/10/an-analysis-and-thought-about-recently.html) and the original [bug report](https://bugs.php.net/bug.php?id=78599) as learning resources in order to implement the exploit in Python.

## Instructions

**Docker on Linux** Run `sudo docker run --rm -ti -p 8080:80 reproduce-cve-2019-11043` to instantiate a barebone NGINX/PHP-FPM server with an empty script at `/script.php`. The Dockerfile for this image is available [here](https://github.com/neex/phuip-fpizdam), though it is not needed to run the aforementioned command. 

**Docker on Mac** Run `sudo docker-compuse up -d` from the `/php/CVE-2019-11043` directory of the [vulhub](https://github.com/vulhub/vulhub) repository. (Compose is included with Docker for Mac.)

Run the exploit script with the command `python3 exploit.py http://localhost:8080/script.php` (or `/index.php` if the second option was used). Upon successful execution, a Web shell will be accessible by appending commands to the URL after `?a=` (e.g., `http://localhost:8080/script.php?a=uname -a`).

*N.B. I did attempt to create an Ansible playbook for this assignment, but I came up against a show-stopping bug documented [here](https://github.com/ansible/ansible/issues/71528). It is not possible to start systemd services on recent Linux kernels (e.g., any Ubuntu LTS release) with an Ansible playbook.*

## Theory

### Vulnerability
PHP-FPM configuration files contain a rule for matching incoming URI requests to PHP scripts which often look like this:
```
location ~ [^/]\.php(/|$) {
  ...
  fastcgi_split_path_info       ^(.+?\.php)(/.*)$;
  fastcgi_param PATH_INFO       $fastcgi_path_info;
  fastcgi_pass                  php:9000;
  ...
}
```
This _should_ match any URI in the form `/script.php/pathinfo`, but `.` actually doesn't match new line `%0a` characters. If the URI contains a new line, it will trigger the following [bug](https://github.com/php/php-src/blob/php-7.3.10/sapi/fpm/fpm/fpm_main.c#L1151) in the PHP implementation:
```
1141    int ptlen = strlen(pt);
1142    int slen = len - ptlen;
1143    int pilen = env_path_info ? strlen(env_path_info) : 0;
1144    int tflag = 0;
1145    char *path_info;
1146    if (apache_was_here) {
1147        /* recall that PATH_INFO won't exist */
1148        path_info = script_path_translated + ptlen;
1149        tflag = (slen != 0 && (!orig_path_info || strcmp(orig_path_info, path_info) != 0));
1150    } else {
1151        path_info = env_path_info ? env_path_info + pilen - slen : NULL;
1152        tflag = (orig_path_info != path_info);
1153    }
```
The issue here is that `slen` is correctly computed as the length of the URI minus the length of the resource path, but `pilen` is mistakenly set to 0. This sets `path_info` to a _negative_ value on line 1151, resulting in a buffer underflow. Immediately after this miscalculation in the same file, we have:
```
1159    FCGI_PUTENV(request, "ORIG_PATH_INFO", orig_path_info);
1160    old = path_info[0];
1161    path_info[0] = 0;
1162    if (!orig_script_name ||
1163        strcmp(orig_script_name, env_path_info) != 0) {
1164        if (orig_script_name) {
1165            FCGI_PUTENV(request, "ORIG_SCRIPT_NAME", orig_script_name);
1166        }
1167        SG(request_info).request_uri = FCGI_PUTENV(request, "SCRIPT_NAME", env_path_info);
1168    } else {
1169        SG(request_info).request_uri = orig_script_name;
1170    }
1171    path_info[0] = old;
```
On line 1161, a null byte is written to the miscalculated memory location from the previous step. This can be leveraged to exploit a vulnerability on line 1165, where FastCGI writes an environment variable. By writing the null byte into the pointer controlling the environment variable write operation, we can insert abitrary PHP variables into the environment with our HTTP requests.

### Exploit

#### FastCGI Internal Data Structures
The environment variables [in FastCGI](https://github.com/php/php-src/blob/php-7.3.10/main/fastcgi.c#L188) are stored in a tightly packed sequence of key-value string pairs in memory. The start and end of the buffer holding these strings is called `_fcgi_data_seg`. If the buffer fills up, a new one is allocated and the `next` member points towards the old one. 
```
118    typedef struct _fcgi_data_seg {
119        char                  *pos;
120        char                  *end;
121    	   struct _fcgi_data_seg *next;
122    	   char                   data[1];
123    } fcgi_data_seg;
```
FastCGI accesses individual environment variables using a hash table called `_fcgi_hash`. 
```
125    typedef struct _fcgi_hash {
126    	   fcgi_hash_bucket  *hash_table[FCGI_HASH_TABLE_SIZE];
127    	   fcgi_hash_bucket  *list;
128        fcgi_hash_buckets *buckets;
129        fcgi_data_seg     *data;
130    } fcgi_hash;
```
The general premise of this exploit is overwriting the `pos` member of the `_fcgi_data_seg` struct in order to overwrite the environment settings.

#### Hash Table Circumvention
Almost immediately after the null byte overwrite, PHP-FPM retrieves the variable `PHP_VALUE` to initialize the environment. 

#### Shell Code Injection
